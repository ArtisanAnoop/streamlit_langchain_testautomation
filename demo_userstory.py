import re
import warnings

import streamlit as st
from dotenv import load_dotenv
from langchain_community.callbacks import get_openai_callback
from langchain_community.chat_models import ChatOpenAI
from langchain.schema import (
    SystemMessage,
    HumanMessage,
    AIMessage
)
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_community.llms.huggingface_hub import HuggingFaceHub

warnings.filterwarnings('ignore')


def init_page():
    # st.set_page_config(
    #     page_title="AI-powered Test Case Generator - Anoop Korappath", page_icon=":bulb:", layout="centered",
    #     initial_sidebar_state="expanded"
    # )
    st.markdown("""
        <style>
            .header {
                font-family: Arial, sans-serif;
                color: #00325B;
                font-size: 24px;
                text-align: center;
                padding: 10px;
                background-color: #FF8C02;
                border: none;
            }
        </style>
        <div class="header">AI-Powered Test Case Generation</div>
    """, unsafe_allow_html=True)
    st.markdown("""
        <div style="text-align: center;">Create test scenarios in Gherkin format from user stories and acceptance criteria.</div>
        """, unsafe_allow_html=True)


def generate_test_scenarios_str(num_functional, num_security, num_usability, num_performance, num_visual,
                                num_accessibility):
    messages = []
    total_tests = num_functional + num_security + num_usability + num_performance + num_visual + num_accessibility

    if num_functional > 0:
        messages.append(f"You should create {num_functional} functional test scenarios")
    if num_security > 0:
        messages.append(f"You should create {num_security} security test scenarios")
    if num_usability > 0:
        messages.append(f"You should create {num_usability} usability test scenarios")
    if num_performance > 0:
        messages.append(f"You should create {num_performance} performance test scenarios")
    if num_visual > 0:
        messages.append(f"You should create {num_visual} visual test scenarios")
    if num_accessibility > 0:
        messages.append(f"You should create {num_accessibility} accessibility test scenarios")

    messages.append(f"Total number of test scenarios required is {total_tests} and it should be in one feature file.")
    return '\n'.join(f"{i + 1}) {message}" for i, message in enumerate(messages))


def select_model():
    model = st.sidebar.radio("Choose a model:", ("GPT-4", "Gemini", "Mistral AI"))
    if model == "GPT-4":
        model_name = "gpt-4"
    elif model == "Gemini":
        model_name = "gemini-1.0-pro-latest"
    else:
        model_name = "mistralai/Mistral-7B-Instruct-v0.2"

    popup_text = """Temperature controls the randomness of text generated by a large language model.  A higher temperature leads to more creative and unexpected output, while a lower temperature produces more predictable and reliable text. [more info](https://www.iguazio.com/glossary/llm-temperature/)"""
    temperature = st.sidebar.slider("Temperature:", min_value=0.0, max_value=1.0, value=0.0, step=0.01, help=popup_text)

    if model == "Gemini":
        return ChatGoogleGenerativeAI(model=model_name, temperature=temperature, convert_system_message_to_human=True)
    elif model == "GPT-4":
        return ChatOpenAI(temperature=temperature, model_name=model_name)
    elif model == "Mistral AI":
        return HuggingFaceHub(
            repo_id=model_name,
            model_kwargs={"temperature": 0.1, "max_tokens": 5000, "top_p": 0.2, "max_new_tokens": 6000,
                          "num_return_sequences": 1})


def get_answer(llm, messages):
    with get_openai_callback() as cb:
        # Check if llm is an instance of HuggingFaceHub
        if isinstance(llm, HuggingFaceHub):
            # Join the content of the messages into a single string
            prompt = ' '.join(message.content for message in messages)
            answer = llm(prompt)
            # Split the output at the last occurrence of the prompt
            _, generated_content = answer.rsplit(prompt, 1)
            return generated_content.strip(), cb.total_cost
        else:
            answer = llm(messages)
            return answer.content, cb.total_cost


def _fix_streamlit_space(text: str) -> str:
    """Fix streamlit issue where a newline needs 2 spaces before it.
    See https://github.com/streamlit/streamlit/issues/868
    """

    def _replacement(match: re.Match):
        # Check if the match is preceded by a space
        if match.group(0).startswith(" "):
            # If preceded by one space, add one more space
            return " \n"
        else:
            # If not preceded by any space, add two spaces
            return "  \n"

    return re.sub(r"( ?)\n", _replacement, text)


def on_click():
    st.session_state.user_story = ""
    st.session_state.functional = 0
    st.session_state.security = 0
    st.session_state.usability = 0
    st.session_state.performance = 0
    st.session_state.visual = 0
    st.session_state.accessibility = 0


def cucumber_to_html(feature_text):
    # Define keywords and their HTML formatting
    keywords = {
        "Feature:": '<b style="color:#67ab05;">Feature:</b>',
        "Scenario:": '<b style="color:#56b1dd">Scenario:</b>',
        "Scenario Outline:": '<b style="color:#56b1dd;">Scenario:</b>',
        "Given": '<span style="color:#ff7343;">Given</span>',
        "When": '<span style="color:#ff7343;">When</span>',
        "Then": '<span style="color:#ff7343;">Then</span>',
        "And": '<span style="color:#ff7343;">And</span>',
        "But": '<span style="color:#ff7343;">But</span>',
        "Examples:": '<b style="color:#d2aa2c;">Examples:</b>',
        "Background:": '<b style="color:#cfb53b;">Background:</b>'
    }

    # Split the text into lines for processing
    lines = feature_text.split('\n')

    # Process each line
    for i in range(len(lines)):
        # Format tags
        if lines[i].strip().startswith('@'):
            lines[i] = f'<span style="color:#9f90bc;"><b>{lines[i].strip()}</b></span>'
        else:
            words = lines[i].split(' ')
            for j, word in enumerate(words):
                if word in keywords:
                    words[j] = keywords[word]
                    break  # Assumes only one keyword per line
            lines[i] = ' '.join(words)

    # Join the lines back into a single string with HTML line breaks
    html_content = "<br>".join(lines)

    # Wrap in basic HTML structure
    return f"<html><body>{html_content}</body></html>"


def main():
    global template
    init_page()
    load_dotenv()
    sidebar = st.sidebar
    sidebar.title("Options")
    llm = select_model()
    help_text = _fix_streamlit_space(
        "\nAs a Financial Accountant, I want to maximise the amount of time that the training rooms are in use, so that I can maximise revenue from the rooms.\n"
        + "Acceptance criteria:\n" +
        "The system should allow me to view the schedule of all training courses and their corresponding rooms.\n" +
        "The system should show me the total amount of time that each room is being used.\n" +
        "The system should allow me to prioritize the scheduling of courses based on the availability of rooms.\n" +
        "The system should prevent me from scheduling a course in a room that is already booked for the entire day.")

    st.write("\n\n\n")
    st.write("\n\n\n")

    user_input = st.text_area("Enter User Story along with Acceptance Criteria", height=200, value="",
                              help=help_text,
                              key="user_story")
    col1, col2, col3 = st.columns([10, 10, 10])
    with col1:
        num_functional = st.number_input("Functional", min_value=0, value=0, key="functional")  # Default value 0
        num_security = st.number_input("Security", min_value=0, value=0, key="security")  # Default value 0
    with col2:
        num_usability = st.number_input("Usability", min_value=0, value=0, key="usability")
        num_performance = st.number_input("Performance", min_value=0, value=0, key="performance")
    with col3:
        num_visual = st.number_input("Visual", min_value=0, value=0, key="visual")
        num_accessibility = st.number_input("Accessibility", min_value=0, value=0, key="accessibility")

    submit = st.button("Generate")
    reset = st.button("Reset", on_click=on_click)

    st.markdown("""
        <style>
             .stButton>button {
                background-color: #FF8C02;
                padding: 14px 20px;
                margin: 8px 0;
                border: none;
                cursor: pointer;
                width: 100%;
                opacity: 0.9;
                font-weight: bold;
                font-family: Arial, sans-serif;
                color: #00325B;
                font-size: 30px;
                text-align: center;
                background-color: #FF8C02;
            }

            .stButton>button:hover {
                opacity:1;
            }
        </style>
        """, unsafe_allow_html=True)

    main_prompt = create_prompt(num_accessibility, num_functional, num_performance, num_security, num_usability,
                                num_visual)

    messages = [SystemMessage(
        content="You are a Software QA engineer expert in writing Cucumber scenarios using Gherkin\n" + main_prompt + "\n\nHere is the actual user story that you have to work on \n\n" + user_input)]  # Initial system message

    if submit:
        messages.append(HumanMessage(content=_fix_streamlit_space(user_input)))
        with st.spinner("Working...."):
            answer, cost = get_answer(llm, messages)
            messages.append(AIMessage(content=_fix_streamlit_space(answer)))
            sidebar.markdown(f"- Cost: ${cost:.5f}")

        for message in messages:
            if isinstance(message, AIMessage):
                with st.chat_message('assistant'):
                    st.markdown(cucumber_to_html(_fix_streamlit_space(message.content)), unsafe_allow_html=True)
            # elif isinstance(message, HumanMessage):
            #     with st.chat_message('user'):
            #         st.write(_fix_streamlit_space(message.content))
    if reset:
        messages = [SystemMessage(
            content="You are an expert in writing Cucumber scenarios using Gherkin\n" + main_prompt + "\n\nHere is the actual user story that you have to work on \n\n" + user_input)]  # Initial system message
        user_input = ""
        st.empty()


def create_prompt(num_accessibility, num_functional, num_performance, num_security, num_usability, num_visual):
    testscenario_by_type = generate_test_scenarios_str(num_functional, num_security, num_usability, num_performance,
                                                       num_visual, num_accessibility)
    main_prompt = f"""

            Task: Your task is to generate test scenarios in Gherkin syntax using Cucumber based on the user story and acceptance criteria provided. You will need to create test scenarios

            Directives: 

            You will receive a user story.A user story is a description of a feature from the end user’s perspective. It typically follows a simple format:

            “As a [user], I want to [action], so that [benefit].”

            For example, let’s say our user story is:

            “As a Financial Accountant, I want to maximise the amount of time that the training rooms are in use, so that I can maximise revenue from the rooms.”

            The Acceptance criteria is optional. It is a list of requirements that must be met in order for the user story to be considered complete and ready for release. It is a way to ensure that the team understands what needs to be done and what the end result should look like.

            The Acceptance criteria for the above user story could be:
            The system should allow me to view the schedule of all training courses and their corresponding rooms.
            The system should show me the total amount of time that each room is being used.
            The system should allow me to prioritize the scheduling of courses based on the availability of rooms.
            The system should prevent me from scheduling a course in a room that is already booked for the entire day.

            Constraints:
            {testscenario_by_type}
            Note: Do not deviate from the above total count of test scenarios.

            Focus Areas:

            1. Understanding the user story: To start, make sure you fully comprehend the user story and its acceptance requirements. This will assist you in determining the essential behaviors and features that require testing.

            2. Utilize techniques for requirement analysis: Use tools for requirement analysis like decision tables, state transition diagrams, or case diagrams to better comprehend the behavior of the system and pinpoint various test scenarios.

            3. Focus on examining the limits of the input values via boundary value analysis: Find the values that fall just below and just above the minimum and maximum valid values. Testing at these crucial moments aids in identifying any flaws.

            4. Partitioning based on equivalence: Classify inputs and outputs according to how they behave. Test representative values from each class because flaws in one class frequently affect all the classes.

            5. Pairwise testing: When there are several input parameters, utilize pairwise testing to choose a small number of test cases that account for all potential parameter combinations. This method offers good coverage while reducing the number of test cases.

            6. Examine negative eventualities: Test cases should take into account negative eventualities in addition to expected actions. Check how the system responds to invalid inputs or unexpected conditions, as well as how errors and exceptions are handled.

            7. Prioritize your test cases by considering the risks involved with the various functionalities.: Concentrate on essential elements, challenging aspects, or troublesome locations.

            6. Create tags for each test scenario based on the priority and type of test case. For example, @Critical, @Functionality, @Security, @Usability, @Performance, @Visual, @Accessibility etc.

            7. The output should be in Gherkin format

            8. Add a tag to each test scenario to identify it uniquely

            9. Use the Scenario Outline and Scenario keywords

            10. Add as much as test data test data as possible for both positive and negative flows

            11. Prioritize the test cases into Low,Medium,High,Critical by considering the risks involved and add tags to each test scenario with the priority value.

            12. Use the Background keyword

            13. Please don't include any other information such as note

            14. The output should be properly formatted Gherkin test scenarios with keywords Feature, Scenario Outline, Scenario, Given, When, Then, And, But, Examples, Background, Tags etc and new lines

            15. The keywords Scenario Outline should be in a new line.

            16. The keywords Scenario should be in a new line.

            17. The keywords Given, When, Then, And, But should be in a new line.

            18. Do not use markdown syntax in the output

            Considerations:
            Parameterized Tests: If applicable, allow for parameterized tests to cover multiple data variations efficiently.
            Error Handling: Ensure proper handling and reporting of failed tests.
            Data Generation: If needed, provide functionality to suggest or generate test data (valid and invalid) based on the schema and test instructions.
            Focus on Behavior: Each scenario should describe actions a user takes and the expected system behavior, not just technical implementation details.
            Multiple Examples: Provide diverse examples (positive, negative, edge cases) within each scenario to thoroughly illustrate the acceptance criteria. Consider using Example tables in Gherkin.
            Clarity and Conciseness: Keep scenarios readable and focused on the essential behavior.
            Data-Driven Approach: Where possible, parameterize scenarios to test with different data sets instead of hardcoding specific values.

            An example of a valid response:

            Feature: User Login and Registration

              @TC_001_Login @Critical @Functionality @Login 
              Scenario Outline: Verify login with credentials
                Given the user "<Username>" is registered with "<Password>"
                When the user attempts to login with "<Username>" and "<Password>"
                Then the login "<Result>" should be displayed

                Examples:
                  | Username      | Password        | Result    |
                  | validUser     | validPassword   | successful|
                  | invalidUser   | validPassword   | fail      |
                  | validUser     | invalidPassword | fail      |
                  | invalidUser   | invalidPassword | fail      |
                  | ""            | ""              | fail      |


            """.strip()
    return main_prompt


if __name__ == '__main__':
    main()