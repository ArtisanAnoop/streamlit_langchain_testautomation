import pandas as pd
from bs4 import BeautifulSoup, NavigableString, Tag
import codecs
import re
import warnings

import streamlit as st
from dotenv import load_dotenv
from langchain_community.callbacks import get_openai_callback
from langchain_community.chat_models import ChatOpenAI
from langchain.schema import (
    SystemMessage,
    HumanMessage,
    AIMessage
)
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.llms import HuggingFaceHub

warnings.filterwarnings('ignore')


def init_page():
    # st.set_page_config(
    #     page_title="AI-powered XPATH Generator - Anoop Korappath", page_icon=":fire:", layout="centered",
    #     initial_sidebar_state="expanded"
    # )
    st.markdown("""
        <style>
            .header {
                font-family: Arial, sans-serif;
                color: #00325B;
                font-size: 24px;
                text-align: center;
                padding: 10px;
                background-color: #FF8C02;
                border: none;
            }
        </style>
        <div class="header">AI-Powered XPath Creation</div>
    """, unsafe_allow_html=True)
    st.markdown("""
        <div style="text-align: center;">Create xpath from html source code</div>
        """, unsafe_allow_html=True)


def select_model():
    model = st.sidebar.radio("Choose a model:", ("GPT-4", "Gemini", "Mistral AI"))
    if model == "GPT-4":
        model_name = "gpt-4"
    elif model == "Gemini":
        model_name = "gemini-1.0-pro-latest"
    else:
        model_name = "mistralai/Mistral-7B-Instruct-v0.2"

    popup_text = """Temperature controls the randomness of text generated by a large language model.  A higher temperature leads to more creative and unexpected output, while a lower temperature produces more predictable and reliable text. [more info](https://www.iguazio.com/glossary/llm-temperature/)"""
    temperature = st.sidebar.slider("Temperature:", min_value=0.0, max_value=1.0, value=0.0, step=0.01, help=popup_text)

    if model == "Gemini":
        return ChatGoogleGenerativeAI(model=model_name, temperature=temperature, convert_system_message_to_human=True)
    elif model == "GPT-4":
        return ChatOpenAI(temperature=temperature, model_name=model_name)
    elif model == "Mistral AI":
        return HuggingFaceHub(
            repo_id=model_name,
            model_kwargs={"temperature": 0.1, "max_tokens": 5000, "top_p": 0.2, "max_new_tokens": 6000,
                          "num_return_sequences": 1})


def get_answer(llm, messages):
    with get_openai_callback() as cb:
        # Check if llm is an instance of HuggingFaceHub
        if isinstance(llm, HuggingFaceHub):
            # Join the content of the messages into a single string
            prompt = ' '.join(message.content for message in messages)
            answer = llm(prompt)
            # Split the output at the last occurrence of the prompt
            _, generated_content = answer.rsplit(prompt, 1)
            return generated_content.strip(), cb.total_cost
        else:
            answer = llm(messages)
            return answer.content, cb.total_cost


def _fix_streamlit_space(text: str) -> str:
    """Fix streamlit issue where a newline needs 2 spaces before it.
    See https://github.com/streamlit/streamlit/issues/868
    """

    def _replacement(match: re.Match):
        # Check if the match is preceded by a space
        if match.group(0).startswith(" "):
            # If preceded by one space, add one more space
            return " \n"
        else:
            # If not preceded by any space, add two spaces
            return "  \n"

    return re.sub(r"( ?)\n", _replacement, text)


def on_click():
    st.session_state.html_source = ""
    st.session_state.keyword = ""


def escape_special_characters(text):
    if isinstance(text, list):
        # Join elements if the attribute is a list (e.g., class)
        text = ' '.join(text)
    return codecs.encode(text, 'unicode_escape').decode('utf-8')


def get_abs_path(element):
    """Recursive function to get absolute path."""
    if element.parent is None or isinstance(element, BeautifulSoup):
        return ''
    parent_path = get_abs_path(element.parent)
    return f'{parent_path}/{element.name}'


def get_sibling_tag(sibling):
    if sibling and isinstance(sibling, Tag):
        return sibling.name
    return "nullna"


def parse_html_to_csv(html_source, keyword):
    soup = BeautifulSoup(html_source, 'html.parser')

    # List of elements to consider
    considered_elements = ['div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'a',
                           'button', 'input', 'select', 'option', 'textarea', 'header',
                           'nav', 'main', 'article', 'section', 'footer', 'table', 'tr', 'td', 'th', 'img', 'label',
                           'b']

    expected_attrs = ['id', 'class', 'style', 'title', 'size', 'dir', 'tabindex', 'hidden', 'for',
                      'accesskey', 'draggable', 'contenteditable', 'href', 'target', 'rel',
                      'download', 'src', 'alt', 'width', 'height', 'type', 'name', 'value',
                      'placeholder', 'enctype', 'maxlength',
                      'cel_widget_id', 'role', 'aria-label', 'data-a-modal',
                      'data-action', 'data-addnewaddress',
                      'data-value', 'aria-describedby', 'data-nav-digest', 'data-nav-selected', 'selected',
                      'autocomplete', 'spellcheck', 'data-nav-ref', 'data-nav-role', 'data-ux-jq-mouseenter',
                      'data-csa-c-type', 'data-csa-c-slot-id', 'data-csa-c-content-id',
                      'aria-hidden', 'data-csa-c-interaction-events', 'data-csa-op-log-render',
                      'data-autorotation-delay', 'data-a-carousel-options', 'data-a-display-strategy',
                      'data-a-transition-strategy', 'data-a-class', 'data-pf_rd_p', 'data-pd_rd_wg', 'data-pd_rd_w',
                      'data-pd_rd_r', 'data-csa-c-painter', 'data-card-metrics-id', 'data-grid-breakpoint',
                      'data-flow-dir', 'data-gwi', 'data-display-at', 'data-order-ws', 'data-order-sm', 'data-ref_',
                      'data-a-card-type', 'data-a-word-break', 'data-a-max-rows', 'data-a-overflow-marker',
                      'data-cy', 'data-slot-name', 'data-scope', 'data-placement-name', 'data-page-type',
                      'data-subpage-type', 'data-iframe-ready', 'data-col-span-ws', 'data-col-span-sm', 'data-item',
                      'data-itemtype', 'data-mediatype', 'data-request', 'data-marketplace-id', 'data-title-id',
                      'data-is-in-watchlist', 'data-csa-c-item-id', 'data-csa-c-posx', 'data-csa-c-owner',
                      'data-component', 'data-metrics', 'data-a-size', 'data-a-color', 'data-a-strike',
                      'data-a-image-source', 'data-a-hires', 'data-ad-feedback-label-id',
                      'data-ad-feedback-client-payload', 'data-ad-feedback-payload', 'data-device-type',
                      'data-current-locale', 'data-is-sponsored-label-active', 'data-form-header-text',
                      'data-dsa-form-header-text', 'data-form-load-error-text', 'data-is-dsa-enabled',
                      'data-should-render-mobile-label', 'data-weblab-treatment', 'cellspacing', 'summary', 'text']

    rows = []
    for element in soup.find_all(considered_elements):
        if isinstance(element, NavigableString):
            continue

        element_data = {'element_type': element.name, 'abs_path': get_abs_path(element)}

        # Extracting siblings
        siblings = list(element.next_siblings)[:3] + [None, None, None]  # Ensuring at least 3 items
        for i, sibling in enumerate(siblings[:3]):
            sibling_path = get_abs_path(sibling) if sibling else "nullna"
            element_data[f'sibling{i + 1}'] = "nullna" if "/None" in sibling_path else sibling_path

        # Extracting only expected attributes
        for attr in expected_attrs:
            if attr in element.attrs:
                value = element.attrs[attr]
                if value == "":
                    element_data[attr] = "emptyornull"
                elif value == " ":
                    element_data[attr] = "justaspace"
                else:
                    element_data[attr] = escape_special_characters(value)
            else:
                element_data[attr] = 'nullna'

        # Extracting text content
        text_content = element.get_text(strip=True)
        element_data['text'] = escape_special_characters(text_content) if text_content else 'nullna'

        rows.append(element_data)

    df = pd.DataFrame(rows)

    # print(df.to_csv(index=False))

    # Create a mask where all columns except 'element_type' are 'nullna'
    mask = (df.loc[:, df.columns != 'element_type'] == 'nullna').all(axis=1)
    # Use the mask to drop the rows from the DataFrame
    df = df.drop(df[mask].index)
    df['df_primary_key'] = range(1, len(df) + 1)

    # Define the new column order
    cols = ['df_primary_key'] + [col for col in df.columns if col != 'df_primary_key']

    # print(df.to_csv(index=False))

    # Reindex the DataFrame
    df = df.reindex(columns=cols).fillna("nullna").drop_duplicates()

    columns_to_drop = [col for col in df.columns if (df[col] == 'nullna').all()]
    df = df.drop(columns=columns_to_drop)

    # Convert the DataFrame to lower case for case insensitive match
    df_lower = df.applymap(lambda s: s.lower() if type(s) == str else s)

    # Convert the keyword to lower case
    keyword_lower = keyword.lower()

    # Create a mask where any column except 'element_type' contains the specific string
    mask = df_lower.drop(columns='element_type').apply(lambda row: row.str.contains(keyword_lower).any(), axis=1)

    # Use the mask to keep only the rows in the DataFrame that contain the specific string
    df = df[mask]

    # Assuming df is your DataFrame
    for col in df.columns:
        if col not in ['df_primary_key', 'element_type', 'abs_path']:
            df[col] = df[col].apply(lambda x: x[:25] if isinstance(x, str) and len(x) > 50 else x)

    ## Remove rows where text contains keyword and other columns do not contain keyword and the element is a div
    # Step 1
    mask_text_contains_keyword = df['text'].str.contains(keyword)

    # Step 2
    mask_other_columns_do_not_contain_keyword = ~df.drop(columns=['element_type', 'text']).apply(
        lambda row: row.str.contains(keyword).any(), axis=1)

    # Step 3
    mask_text_contains_keyword_and_other_columns_do_not = mask_text_contains_keyword & mask_other_columns_do_not_contain_keyword

    # Step 4
    mask_element_type_is_div = df['element_type'] == 'div'

    # Step 5
    mask_final = mask_text_contains_keyword_and_other_columns_do_not & mask_element_type_is_div

    # Step 6
    df = df.drop(df[mask_final].index)

    # Remove rows where the 'abs_path' of one row is contained in the 'abs_path' of another row
    # Step 1: Group the DataFrame by the 'text' column
    groups = df.groupby('text')

    # Initialize an empty list to hold the indices of rows to drop
    rows_to_drop = []

    # Step 2: For each group
    for name, group in groups:
        # If there are more than one rows in the group
        if len(group) > 1:
            # Compare the 'abs_path' of each pair of rows
            for i in range(len(group)):
                for j in range(i + 1, len(group)):
                    # If the 'abs_path' of one row is contained in the 'abs_path' of the other row
                    if group.iloc[i]['abs_path'] in group.iloc[j]['abs_path']:
                        # Mark the row with the shorter 'abs_path' for deletion
                        rows_to_drop.append(group.iloc[i].name)
                    elif group.iloc[j]['abs_path'] in group.iloc[i]['abs_path']:
                        # Mark the row with the shorter 'abs_path' for deletion
                        rows_to_drop.append(group.iloc[j].name)

    # Step 4: Delete the rows that were marked for deletion
    df = df.drop(rows_to_drop)

    return df


def create_prompt():
    prompt = """Objective: Create XPath expressions for web elements described in text presented in CSV format, focusing on a particular keyword. This text includes columns like element type, absolute path, siblings, ID, class, text, etc.

Process:

Examine the CSV-Formatted Text: Carefully read through the CSV-formatted text, paying attention to columns relevant to XPath generation such as text, element_type, id, class, and abs_path.

Keyword Matching Approach: Identify elements where the text attribute aligns with the given keyword, following a structured approach:

Exact Match: First, find elements whose text attribute exactly matches the keyword. If there are more than one such elements create xpath for all of them.
Case-Insensitive Match: If no exact match is found, look for a case-insensitive match.
Partial String Match: Next, identify elements that contain the keyword as part of their text and be case insensitive.
XPath Construction Strategy: Depending on the type of match, construct the XPath:

Direct Text Match: Use text() for elements with an exact text match.Ignore other attributes. xpath will be //element_type[text()='keyword']
Example: For a button with text "Submit", XPath: //button[text()='Submit']
Case-Insensitive or Contains Match: Utilize functions like contains() or translate() for partial case-insensitive matches.
Example: For "submit" case-insensitively in a div: XPath: //div[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'submit')]
Attribute-Based Approach: When text matching isn't ideal, rely on attributes like id or class.
Example: Element with id="loginBtn": XPath: //*[@id='loginBtn']
Utilizing Absolute Path: Use abs_path for more specific targeting when other methods fall short.
Example: Absolute path XPath: /html/body/div[1]/section/div[3]/button
Documentation of XPath Expressions: List the generated XPath expressions, categorizing them by the match type (Exact, Case-Insensitive, etc.).

Output: Provide a clear presentation of the XPath expressions, indicating the match type for each.

Example Scenarios:

Keyword: "My learning"
csv row to select for creating xpath is:
df_primary_key,element_type,abs_path,sibling1,sibling2,sibling3,id,class,style,title,tabindex,for,href,target,rel,src,alt,width,height,type,name,value,placeholder,role,aria-label,aria-describedby,autocomplete,aria-hidden,text
911,span,/html/body/div/div/div/div/div/div/div/a/span,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,nullna,My learning
XPath for the above row is: //span[text()='My learning'] 
The reason is that the text attribute of the span element exactly matches the keyword "My learning".

Keyword: "Register"
Exact Text Match: XPath for a link element with text "Register": //a[text()='Register']
Case-Insensitive Match: XPath for a span with "register" (case-insensitive): //span[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'register')]
Case-Insensitive Partial Match: XPath for a div containing "reg": //div[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'reg')]

This manual approach requires a detailed review of the CSV-formatted text to determine the most effective XPath based on element attributes and the nature of the keyword match."""

    return prompt


def main():
    global template
    init_page()
    load_dotenv()
    sidebar = st.sidebar
    sidebar.title("Options")
    llm = select_model()

    help_text = _fix_streamlit_space(
        "keyword can be any text that you want to search in the html source code. For example, if you want to search for a specific class name, you can enter the class name as the keyword. If you want to search for a specific id, you can enter the id as the keyword. If you want to search for a specific tag, you can enter the tag name as the keyword.")

    st.write("\n\n\n")
    st.write("\n\n\n")

    html_source = st.text_area("Enter the html source", height=200, value="",
                               key="html_source")
    keyword = st.text_input("Enter the keyword", value="", help=help_text,
                            key="keyword")

    submit = st.button("Generate")
    reset = st.button("Reset", on_click=on_click)

    st.markdown("""
        <style>
             .stButton>button {
                background-color: #FF8C02;
                padding: 14px 20px;
                margin: 8px 0;
                border: none;
                cursor: pointer;
                width: 100%;
                opacity: 0.9;
                font-weight: bold;
                font-family: Arial, sans-serif;
                color: #00325B;
                font-size: 30px;
                text-align: center;
                background-color: #FF8C02;
            }

            .stButton>button:hover {
                opacity:1;
            }
        </style>
        """, unsafe_allow_html=True)

    initial_human_message = ""
    if submit:
        df = parse_html_to_csv(html_source, keyword)
        main_prompt = create_prompt()
        print(df.to_csv(index=False))
        initial_human_message = main_prompt + "\n\nHere is the actual csv and keyword that you have to work on \n\n" + "csv is \n" + df.to_csv(
            index=False) + "\n\n and keyword is " + keyword

        messages = [SystemMessage(
            content="You are a Software QA engineer expert in creating xpath for web automation testing.\n" + initial_human_message),
        ]

        messages.append(HumanMessage(content=_fix_streamlit_space(df.to_csv())))
        with st.spinner("Working...."):
            answer, cost = get_answer(llm, messages)
            messages.append(AIMessage(content=_fix_streamlit_space(answer)))
            sidebar.markdown(f"- Cost: ${cost:.5f}")

        for message in messages:
            if isinstance(message, AIMessage):
                with st.chat_message('assistant'):
                    st.markdown(_fix_streamlit_space(message.content), unsafe_allow_html=True)
            # elif isinstance(message, HumanMessage):
            #     with st.chat_message('user'):
            #         st.write(_fix_streamlit_space(message.content))
    if reset:
        messages = [SystemMessage(
            content="You are a Software QA engineer expert in creating xpath for web automation testing.\n" + initial_human_message),
            HumanMessage(
                content=initial_human_message)
        ]
        st.empty()


if __name__ == '__main__':
    main()