import pandas as pd
from bs4 import BeautifulSoup, NavigableString, Tag
import codecs
import re
import warnings

import streamlit as st
from dotenv import load_dotenv
from langchain_community.callbacks import get_openai_callback
from langchain_community.chat_models import ChatOpenAI
from langchain.schema import (
    SystemMessage,
    HumanMessage,
    AIMessage
)
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.llms import HuggingFaceHub

warnings.filterwarnings('ignore')


def init_page():
    # st.set_page_config(
    #     page_title="AI-powered XPATH Generator - Anoop Korappath", page_icon=":fire:", layout="centered",
    #     initial_sidebar_state="expanded"
    # )
    st.markdown("""
        <style>
            .header {
                font-family: Arial, sans-serif;
                color: #00325B;
                font-size: 24px;
                text-align: center;
                padding: 10px;
                background-color: #FF8C02;
                border: none;
            }
        </style>
        <div class="header">AI-Powered XPath Creation</div>
    """, unsafe_allow_html=True)
    st.markdown("""
        <div style="text-align: center;">Create xpath from html source code</div>
        """, unsafe_allow_html=True)


def select_model():
    model = st.sidebar.radio("Choose a model:", ("GPT-4", "Gemini", "Mistral AI"))
    if model == "GPT-4":
        model_name = "gpt-4"
    elif model == "Gemini":
        model_name = "gemini-1.0-pro-latest"
    else:
        model_name = "mistralai/Mistral-7B-Instruct-v0.2"

    popup_text = """Temperature controls the randomness of text generated by a large language model.  A higher temperature leads to more creative and unexpected output, while a lower temperature produces more predictable and reliable text. [more info](https://www.iguazio.com/glossary/llm-temperature/)"""
    temperature = st.sidebar.slider("Temperature:", min_value=0.0, max_value=1.0, value=0.0, step=0.01, help=popup_text)

    if model == "Gemini":
        return ChatGoogleGenerativeAI(model=model_name, temperature=temperature, convert_system_message_to_human=True)
    elif model == "GPT-4":
        return ChatOpenAI(temperature=temperature, model_name=model_name)
    elif model == "Mistral AI":
        return HuggingFaceHub(
            repo_id=model_name,
            model_kwargs={"temperature": 0.1, "max_tokens": 5000, "top_p": 0.2, "max_new_tokens": 6000,
                          "num_return_sequences": 1})


def get_answer(llm, messages):
    with get_openai_callback() as cb:
        # Check if llm is an instance of HuggingFaceHub
        if isinstance(llm, HuggingFaceHub):
            # Join the content of the messages into a single string
            prompt = ' '.join(message.content for message in messages)
            answer = llm(prompt)
            # Split the output at the last occurrence of the prompt
            _, generated_content = answer.rsplit(prompt, 1)
            return generated_content.strip(), cb.total_cost
        else:
            answer = llm(messages)
            return answer.content, cb.total_cost


def _fix_streamlit_space(text: str) -> str:
    """Fix streamlit issue where a newline needs 2 spaces before it.
    See https://github.com/streamlit/streamlit/issues/868
    """

    def _replacement(match: re.Match):
        # Check if the match is preceded by a space
        if match.group(0).startswith(" "):
            # If preceded by one space, add one more space
            return " \n"
        else:
            # If not preceded by any space, add two spaces
            return "  \n"

    return re.sub(r"( ?)\n", _replacement, text)


def on_click():
    st.session_state.html_source = ""
    st.session_state.keyword = ""


def escape_special_characters(text):
    if isinstance(text, list):
        # Join elements if the attribute is a list (e.g., class)
        text = ' '.join(text)
    return codecs.encode(text, 'unicode_escape').decode('utf-8')


def get_abs_path(element):
    """Recursive function to get absolute path."""
    if element.parent is None or isinstance(element, BeautifulSoup):
        return ''
    parent_path = get_abs_path(element.parent)
    return f'{parent_path}/{element.name}'


def get_sibling_tag(sibling):
    if sibling and isinstance(sibling, Tag):
        return sibling.name
    return "nullna"


def parse_html_to_csv(html_source, keyword):
    soup = BeautifulSoup(html_source, 'html.parser')

    # List of elements to consider
    considered_elements = ['div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'a',
                           'button', 'input', 'select', 'option', 'textarea', 'header',
                           'nav', 'main', 'article', 'section', 'footer', 'table', 'tr', 'td', 'th', 'img', 'label',
                           'b']

    expected_attrs = ['id', 'class', 'style', 'title', 'size', 'dir', 'tabindex', 'hidden', 'for',
                      'accesskey', 'draggable', 'contenteditable', 'href', 'target', 'rel',
                      'download', 'src', 'alt', 'width', 'height', 'type', 'name', 'value',
                      'placeholder', 'enctype', 'maxlength',
                      'cel_widget_id', 'role', 'aria-label', 'data-a-modal',
                      'data-action', 'data-addnewaddress',
                      'data-value', 'aria-describedby', 'data-nav-digest', 'data-nav-selected', 'selected',
                      'autocomplete', 'spellcheck', 'data-nav-ref', 'data-nav-role', 'data-ux-jq-mouseenter',
                      'data-csa-c-type', 'data-csa-c-slot-id', 'data-csa-c-content-id',
                      'aria-hidden', 'data-csa-c-interaction-events', 'data-csa-op-log-render',
                      'data-autorotation-delay', 'data-a-carousel-options', 'data-a-display-strategy',
                      'data-a-transition-strategy', 'data-a-class', 'data-pf_rd_p', 'data-pd_rd_wg', 'data-pd_rd_w',
                      'data-pd_rd_r', 'data-csa-c-painter', 'data-card-metrics-id', 'data-grid-breakpoint',
                      'data-flow-dir', 'data-gwi', 'data-display-at', 'data-order-ws', 'data-order-sm', 'data-ref_',
                      'data-a-card-type', 'data-a-word-break', 'data-a-max-rows', 'data-a-overflow-marker',
                      'data-cy', 'data-slot-name', 'data-scope', 'data-placement-name', 'data-page-type',
                      'data-subpage-type', 'data-iframe-ready', 'data-col-span-ws', 'data-col-span-sm', 'data-item',
                      'data-itemtype', 'data-mediatype', 'data-request', 'data-marketplace-id', 'data-title-id',
                      'data-is-in-watchlist', 'data-csa-c-item-id', 'data-csa-c-posx', 'data-csa-c-owner',
                      'data-component', 'data-metrics', 'data-a-size', 'data-a-color', 'data-a-strike',
                      'data-a-image-source', 'data-a-hires', 'data-ad-feedback-label-id',
                      'data-ad-feedback-client-payload', 'data-ad-feedback-payload', 'data-device-type',
                      'data-current-locale', 'data-is-sponsored-label-active', 'data-form-header-text',
                      'data-dsa-form-header-text', 'data-form-load-error-text', 'data-is-dsa-enabled',
                      'data-should-render-mobile-label', 'data-weblab-treatment', 'cellspacing', 'summary', 'text']

    rows = []
    for element in soup.find_all(considered_elements):
        if isinstance(element, NavigableString):
            continue

        element_data = {'element_type': element.name, 'abs_path': get_abs_path(element)}

        # Extracting siblings
        siblings = list(element.next_siblings)[:3] + [None, None, None]  # Ensuring at least 3 items
        for i, sibling in enumerate(siblings[:3]):
            sibling_path = get_abs_path(sibling) if sibling else "nullna"
            element_data[f'sibling{i + 1}'] = "nullna" if "/None" in sibling_path else sibling_path

        # Extracting only expected attributes
        for attr in expected_attrs:
            if attr in element.attrs:
                value = element.attrs[attr]
                if value == "":
                    element_data[attr] = "emptyornull"
                elif value == " ":
                    element_data[attr] = "justaspace"
                else:
                    element_data[attr] = escape_special_characters(value)
            else:
                element_data[attr] = 'nullna'

        # Extracting text content
        text_content = element.get_text(strip=True)
        element_data['text'] = escape_special_characters(text_content) if text_content else 'nullna'

        rows.append(element_data)

    df = pd.DataFrame(rows)

    # print(df.to_csv(index=False))

    # Create a mask where all columns except 'element_type' are 'nullna'
    mask = (df.loc[:, df.columns != 'element_type'] == 'nullna').all(axis=1)
    # Use the mask to drop the rows from the DataFrame
    df = df.drop(df[mask].index)
    df['df_primary_key'] = range(1, len(df) + 1)

    # Define the new column order
    cols = ['df_primary_key'] + [col for col in df.columns if col != 'df_primary_key']

    # print(df.to_csv(index=False))

    # Reindex the DataFrame
    df = df.reindex(columns=cols).fillna("nullna").drop_duplicates()

    columns_to_drop = [col for col in df.columns if (df[col] == 'nullna').all()]
    df = df.drop(columns=columns_to_drop)

    # Convert the DataFrame to lower case for case insensitive match
    df_lower = df.applymap(lambda s: s.lower() if type(s) == str else s)

    # Convert the keyword to lower case
    keyword_lower = keyword.lower()

    # Create a mask where any column except 'element_type' contains the specific string
    mask = df_lower.drop(columns='element_type').apply(lambda row: row.str.contains(keyword_lower).any(), axis=1)

    # Use the mask to keep only the rows in the DataFrame that contain the specific string
    df = df[mask]

    # Assuming df is your DataFrame
    for col in df.columns:
        if col not in ['df_primary_key', 'element_type', 'abs_path']:
            df[col] = df[col].apply(lambda x: x[:25] if isinstance(x, str) and len(x) > 50 else x)

    ## Remove rows where text contains keyword and other columns do not contain keyword and the element is a div
    # Step 1
    mask_text_contains_keyword = df['text'].str.contains(keyword)

    # Step 2
    mask_other_columns_do_not_contain_keyword = ~df.drop(columns=['element_type', 'text']).apply(
        lambda row: row.str.contains(keyword).any(), axis=1)

    # Step 3
    mask_text_contains_keyword_and_other_columns_do_not = mask_text_contains_keyword & mask_other_columns_do_not_contain_keyword

    # Step 4
    mask_element_type_is_div = df['element_type'] == 'div'

    # Step 5
    mask_final = mask_text_contains_keyword_and_other_columns_do_not & mask_element_type_is_div

    # Step 6
    df = df.drop(df[mask_final].index)

    # Remove rows where the 'abs_path' of one row is contained in the 'abs_path' of another row
    # Step 1: Group the DataFrame by the 'text' column
    groups = df.groupby('text')

    # Initialize an empty list to hold the indices of rows to drop
    rows_to_drop = []

    # Step 2: For each group
    for name, group in groups:
        # If there are more than one rows in the group
        if len(group) > 1:
            # Compare the 'abs_path' of each pair of rows
            for i in range(len(group)):
                for j in range(i + 1, len(group)):
                    # If the 'abs_path' of one row is contained in the 'abs_path' of the other row
                    if group.iloc[i]['abs_path'] in group.iloc[j]['abs_path']:
                        # Mark the row with the shorter 'abs_path' for deletion
                        rows_to_drop.append(group.iloc[i].name)
                    elif group.iloc[j]['abs_path'] in group.iloc[i]['abs_path']:
                        # Mark the row with the shorter 'abs_path' for deletion
                        rows_to_drop.append(group.iloc[j].name)

    # Step 4: Delete the rows that were marked for deletion
    df = df.drop(rows_to_drop)

    # Remove all columns where all values are 'nullna'
    columns_to_drop = [col for col in df.columns if (df[col] == 'nullna').all()]
    df = df.drop(columns=columns_to_drop)

    # Replace 'nullna' with 'null' in the 'text' column for all divs
    df.loc[df['element_type'] == 'div', 'text'] = 'nullna'
    return df


def create_prompt():
    prompt = """Task: Generate XPaths to locate HTML elements based on a keyword that matches an attribute value.

Input:

A CSV file containing the following columns:
element_type: The type of HTML element (e.g., div, span, input, button).
id: The element's ID attribute (if present).
class: The element's class attribute (if present).
abs_path: The absolute XPath of the element.
sibling1: The absolute XPath of the first sibling of the element.
sibling2: The absolute XPath of the second sibling of the element.
sibling3: The absolute XPath of the third sibling of the element.
id: The element's ID attribute (if present).
class: The element's class attribute (if present).
style: The element's style attribute (if present).
title: The element's title attribute (if present).
href:   The element's href attribute (if present).    
target: The element's target attribute (if present).
src:   The element's src attribute (if present).
alt:  The element's alt attribute (if present).
width: The element's width attribute (if present).
height: The element's height attribute (if present).
type: The element's type attribute (if present).
name: The element's name attribute (if present).
value: The element's value attribute (if present).
text: The text content of the element.

Keyword Matching Strategy:

Do not take into account nullna values while creating XPaths.
While generating XPaths, consider the following attributes in the order of priority: 'id', 'class', 'name', 'href', 'text' etc
Prioritize Reliability: Give preference to XPath expressions that are the most likely to be unique and stable across potential website changes.
Exact Matches: Begin by searching for elements where the keyword matches the entire value of an attribute:
id: If a matching 'id' exists, it's the most reliable choice: //*[@id='keyword']
Other Attributes: Look for exact matches on attributes like 'name', 'class', etc.: //element_type[@attribute='keyword']
Case-Insensitive Matches: If no exact matches are found:
translate(): Use the translate() function to make comparisons case-insensitive: //element_type[translate(@attribute, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') = 'keyword']
Partial Matches with Contains: When case-insensitive exact matches fail, look for partial matches:
contains(): Utilize the contains() function: //element_type[contains(@attribute, 'keyword')]
Specificity: Balance between finding matches and avoiding overly broad results.
Text Content Matching: Consider text content for matching if appropriate:
text(): For simple matches: //element_type[text()='keyword']
Case Sensitivity: Employ translate() for case-insensitive text matches.
Contextual XPath Generation:

Attribute Availability: If multiple matching attributes exist, prioritize the most reliable ones (usually 'id' > 'class' > 'name').
Absolute Paths: While 'abs_path' can be specific, try to construct XPaths that are more resilient to minor structural website changes. Only use abs_path in exceptional cases for precise targeting, as it can be brittle to changes in the HTML structure.
Specificity: Aim for XPaths that are specific enough to match the target element but not overly specific so as to become brittle.

Output:
Clearly Formatted: Present the generated XPath expressions in a well-organized manner
Match Type: Indicate the matching strategy used for each XPath (e.g., Exact ID Match, Case-Insensitive Attribute, Partial Text Contains).
Additional Notes: If necessary, include comments for complex XPaths or to explain decisions made.
Clearly present the generated XPaths.
Indicate the match type: "Exact", "Case-Insensitive", "Partial", or "Absolute Path".

Example Scenarios:

Keyword: "My learning"

CSV row: element_type=span, text=My learning
XPath: //span[text()='My learning']
Reason: The text attribute of the span element is an exact match for "My learning".
Keyword: "username"
Relevant CSV rows include elements with various attributes.
For exact text match: Use XPath for elements where name='username', e.g., //input[@name='username'].
For case-insensitive match: For example, XPath for a case-insensitive match of name='username' is //input[translate(@name, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') = 'username'].
For partial match: XPath for elements containing "user", e.g., //input[contains(@name, 'user')].

"""

    return prompt


def main():
    global template
    init_page()
    load_dotenv()
    sidebar = st.sidebar
    sidebar.title("Options")
    llm = select_model()

    help_text = _fix_streamlit_space(
        "keyword can be any text that you want to search in the html source code. For example, if you want to search for a specific class name, you can enter the class name as the keyword. If you want to search for a specific id, you can enter the id as the keyword. If you want to search for a specific tag, you can enter the tag name as the keyword.")

    st.write("\n\n\n")
    st.write("\n\n\n")

    html_source = st.text_area("Enter the html source", height=200, value="",
                               key="html_source")
    keyword = st.text_input("Enter the keyword", value="", help=help_text,
                            key="keyword")

    submit = st.button("Generate")
    reset = st.button("Reset", on_click=on_click)

    st.markdown("""
        <style>
             .stButton>button {
                background-color: #FF8C02;
                padding: 14px 20px;
                margin: 8px 0;
                border: none;
                cursor: pointer;
                width: 100%;
                opacity: 0.9;
                font-weight: bold;
                font-family: Arial, sans-serif;
                color: #00325B;
                font-size: 30px;
                text-align: center;
                background-color: #FF8C02;
            }

            .stButton>button:hover {
                opacity:1;
            }
        </style>
        """, unsafe_allow_html=True)

    initial_human_message = ""
    if submit:
        df = parse_html_to_csv(html_source, keyword)
        main_prompt = create_prompt()
        print(df.to_csv(index=False))
        initial_human_message = main_prompt + "\n\nHere is the actual csv and keyword that you have to work on \n\n" + "csv is \n" + df.to_csv(
            index=False) + "\n\n and keyword is " + keyword

        messages = [SystemMessage(
            content="You are a Software QA engineer expert in creating xpath for web automation testing.\n" + initial_human_message),
        ]

        messages.append(HumanMessage(content=_fix_streamlit_space(df.to_csv())))
        with st.spinner("Working...."):
            answer, cost = get_answer(llm, messages)
            messages.append(AIMessage(content=_fix_streamlit_space(answer)))
            sidebar.markdown(f"- Cost: ${cost:.5f}")

        for message in messages:
            if isinstance(message, AIMessage):
                with st.chat_message('assistant'):
                    st.markdown(_fix_streamlit_space(message.content), unsafe_allow_html=True)
            # elif isinstance(message, HumanMessage):
            #     with st.chat_message('user'):
            #         st.write(_fix_streamlit_space(message.content))
    if reset:
        messages = [SystemMessage(
            content="You are a Software QA engineer expert in creating xpath for web automation testing.\n" + initial_human_message),
            HumanMessage(
                content=initial_human_message)
        ]
        st.empty()


if __name__ == '__main__':
    main()
